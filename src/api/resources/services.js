import resource from 'resource-router-middleware';
import response from '../concerns/response';
import Raven from "raven";
import { getPaginatorOptions } from "../concerns/modifiers";
import constants from '../../config/constants.json';
import config from '../../config';

const _ = require('lodash');
const moment = require('moment');
const Model = require('../../models/index').Service;
const Resource = require('../../models/index').Resource;
const Case = require('../../models/index').Case;
const DocumentPreparation = require('../../models/index').DocumentPreparation;
const EDDLien = require('../../models/index').EDDLien;
const InjuredWorkerInformation = require('../../models/index').InjuredWorkerInformation;
const InjuredWorkerOutreach = require('../../models/index').InjuredWorkerOutreach;
const LienService = require('../../models/index').LienService;
const Walkthrough = require('../../models/index').Walkthrough;
const Misc = require('../../models/index').Misc;
const ServiceTag = require('../../models/index').ServiceTag;
const Organisation = require('../../models/index').Organisation;
const ContactProfile = require('../../models/index').ContactProfile;
const Claim = require('../../models/index').Claim;
const Venue = require('../../models/index').Venue;
const Judge = require('../../models/index').Judge;
const Track = require('../../models/index').Track;
const Tasks = require('../../models/index').Tasks;
const ServiceActions = require('../../models/index').ServiceActions;
const serviceInformation = {
  documentPreparation: DocumentPreparation,
  eddLien: EDDLien,
  injuredWorkerInformation: InjuredWorkerInformation,
  injuredWorkerOutreach: InjuredWorkerOutreach,
  lienService: LienService,
  walkthrough: Walkthrough,
  misc: Misc
};
const fieldName = {
  documentPreparation: "documentPreparationId",
  eddLien: "eddLienId",
  injuredWorkerInformation: "injuredWorkerInformationId",
  injuredWorkerOutreach: "injuredWorkerOutreachId",
  lienService: "lienServiceId",
  walkthrough: "walkthroughId",
  misc: "miscId"
};
const convertFromTrackToTask = (track) => ({
  name: track.name,
  description: track.description,
  summary: track.summary,
  dueDate: track.dueDate,
  priority: track.priority,
  workerId: track.preAssignedTo,
  autogenerated: true,
  parentCasePhase: track.phase,
  taskType: track.taskType,
  order: track.position,
  trackIdParent: track.id
});

/**
 * For requests with an `id`, you can auto-load the entity.
 *  Errors terminate the request, success sets `req[id] = data`.
 */
const load = async (req, id, callback) => {
  try {
    const model = await Model.findById(id, {
      include: [
        {
          model: DocumentPreparation,
          as: 'documentPreparation'
        },
        {
          model: EDDLien,
          as: 'eddLien'
        },
        {
          model: InjuredWorkerInformation,
          as: 'injuredWorkerInformation'
        },
        {
          model: InjuredWorkerOutreach,
          as: 'injuredWorkerOutreach'
        },
        {
          model: LienService,
          as: 'lienService'
        },
        {
          model: Walkthrough,
          as: 'walkthrough'
        },
        {
          model: Misc,
          as: 'misc'
        },
        {
          model: ServiceTag,
          as: 'tags'
        },
        {
          model: Claim,
          as: 'claims'
        },
        {
          model: ContactProfile,
          as: 'invoicer'
        },
        {
          model: ContactProfile,
          as: 'serviceOwner'
        },
        {
          model: ContactProfile,
          as: 'referredBy'
        },
        {
          model: ContactProfile,
          as: 'currentClaimHandler'
        },
        {
          model: Venue,
          as: 'venue'
        },
        {
          model: Venue,
          as: 'actualVenue'
        },
        {
          model: Judge,
          as: 'judge'
        },
        {
          model: ContactProfile,
          as: 'applicantAttorney'
        },
        {
          model: Case,
          as: 'case',
          include: [
            {
              model: ContactProfile,
              as: 'injuredWorker'
            },
            {
              model: Organisation,
              as: 'account'
            }
          ]
        },
      ]
    });

    if(model) {
      callback(null, model);
    } else {
      callback(response(null).error('Not found', 404));
    }
  } catch(err) {
    Raven.captureException(err);
    callback(response(null).error('Internal server error', 500));
  }
};

/**
 * Creates a transaction in the db, in order to create a service
 *
 * @param db
 * @param req
 * @param res
 * @return {Promise<T>}
 */
const createService = (db, req, res) => {
  const { body, params } = req;
  const { caseId } = params;

  return db.transaction((t) => {
    return Model.create({
      ...body,
      caseId,
      status: ((body.requestedStatus === 'save') ? 'in_progress' : body.requestedStatus),
      onHold: (body.requestedStatus === 'hold')
    }, {transaction: t})
      .then(async (data) => {
        const promises = [];
        if(body.requestedStatus === 'hold') {
          promises.push(ServiceActions.create({
            serviceId: data.id,
            profileId: req.user.profileId,
            action: "hold",
            startDate: moment().format(config.dateWithTimezone)
          }, {transaction: t}));
        }
        return Promise.all(promises).then(() => data).catch((err) => Promise.reject(err));
      })
    /** Creating service type child record */
      .then(async (data) => {
        const child = await serviceInformation[data.serviceType].create({
          ...body[data.serviceType],
          updateIntervalMonths: constants.updateIntervalsMonths[body.serviceType],
        }, {transaction: t});
        return {
          parentId: data.id,
          childId: child.id,
          field: fieldName[data.serviceType]
        };
      })
      /** Updating service parent record with the child Id*/
      .then((data) => {
        const modelData = {};
        modelData[data.field] = data.childId;
        return Model.update(modelData, {where: {id: data.parentId}, transaction: t}).then(() => data).catch((err) => Promise.reject(err));
      })
      /** Creating service tags */
      .then((data) => {
        const promises = [];
        if(!_.isEmpty(body.tags)) {
          for(const tag of body.tags) {
            promises.push(ServiceTag.create({...tag, serviceId: data.parentId}, {transaction: t}));
          }
        }
        return Promise.all(promises).then(() => data).catch((err) => Promise.reject(err));
      })
      /** Creating claims */
      .then((data) => {
        const promises = [];
        if(!_.isEmpty(body.claims)) {
          for(const claim of body.claims) {
            promises.push(Claim.create({...claim, serviceId: data.parentId}, {transaction: t}));
          }
        }
        return Promise.all(promises).then(() => data).catch((err) => Promise.reject(err));
      })
      /** Creating tasks according to tracks */
      .then(async (data) => {
        const promises = [];
        const tracks = await Track.findAll({where: {serviceType: body.serviceType}});
        for(const track of tracks) {
          promises.push(Tasks.create(convertFromTrackToTask(track), {transaction: t}).then((task) => {
            return Resource.create({workerId: track.preAssignedTo, serviceId: data.parentId}, {transaction: t})
              .then((resource) => {
                return Tasks.update({resourceId: resource.id}, {where: {id: task.id}, transaction: t});
              })
          }));
        }
        return Promise.all(promises).then(() => data).catch((err) => Promise.reject(err));
      })
      .then(async (data) => {
        const notifyLastTouchDaysNo = constants.lastTouchInterval[body.serviceType] || 1;
        return Case.update({
          notifyLastTouch: moment().add(notifyLastTouchDaysNo, 'days').startOf('day').format(config.dateWithTimezone),
          notifyLastTouchDaysNo
        }, {where: {id: params.caseId}}).then(() => data).catch((err) => Promise.reject(err));
      });
  }).then(function (data) {
    // Transaction has been committed
    load(req, data.parentId, (err, model) => response(res).item(model));
  }).catch(function (err) {
    Raven.captureException(err);
    response(res).error(err, 500);
  });
};

/**
 * Creates a transaction in the db, in order to update a service
 *
 * @param db
 * @param model
 * @param body
 * @param caseId
 * @param res
 * @return {Promise<T>}
 */
const updateServices = (db, { model, body, params }, res) => {
  const { caseId } = params;
  const tagIds = model.tags.map(tag => tag.id);
  const claimIds = model.claims.map(claim => claim.id);
  const serviceId = model.id;

  return db.transaction((t) => {
    return model.updateAttributes({
      ...body,
      caseId,
      status: ((body.requestedStatus === 'save') ? 'in_progress' : body.requestedStatus),
      onHold: (body.requestedStatus === 'hold')
    }, {transaction: t})
      .then(async (data) => {
        const promises = [];
        if(body.requestedStatus === 'hold') {
          promises.push(ServiceActions.update(
            {endDate: moment().format(config.dateWithTimezone)},
            {where: {serviceId: data.id, action: "hold", endDate: null}, transaction: t}
          ));
        }
        return Promise.all(promises).then(() => data).catch((err) => Promise.reject(err));
      })
      .then((data) => {
        return serviceInformation[data.serviceType].update(_.extend({}, body[data.serviceType]), {where: {id: data[fieldName[data.serviceType]]}, transaction: t});
      })
      .then(() => {
        const promises = [];

        if(typeof body.tags !== "undefined") {
          for(const tag of body.tags) {
            if(tagIds.indexOf(tag.id) !== -1) {
              delete tagIds[tagIds.indexOf(tag.id)];
              promises.push(ServiceTag.update({...tag, serviceId: serviceId}, {where: {id: tag.id}, transaction: t}));
            } else {
              promises.push(ServiceTag.create({...tag, serviceId: serviceId}, {transaction: t}));
            }
          }

          for(const remainingId of tagIds) {
            promises.push(ServiceTag.destroy({where: {id: remainingId}}, {transaction: t}));
          }
        }

        return Promise.all(promises);
      }).then(() => {
        const promises = [];

        if(!_.isEmpty(body.claims)) {
          for(const claim of body.claims) {
            if(claimIds.indexOf(claim.id) !== -1) {
              delete claimIds[claimIds.indexOf(claim.id)];
              promises.push(Claim.update({...claim, serviceId: serviceId}, {where: {id: claim.id}, transaction: t}));
            } else {
              promises.push(Claim.create({...claim, serviceId: serviceId}, {transaction: t}));
            }
          }
        }

        for(const remainingId of claimIds) {
          promises.push(Claim.destroy({where: {id: remainingId}}, {transaction: t}));
        }
        return Promise.all(promises);
      }).then(async (data) => {
        const notifyLastTouchDaysNo = constants.lastTouchInterval[body.serviceType] || 1;
        return Case.update({
          notifyLastTouch: moment().add(notifyLastTouchDaysNo, 'days').startOf('day').format(config.dateWithTimezone),
          notifyLastTouchDaysNo
        }, {where: {id: params.caseId}}).then(() => data).catch((err) => Promise.reject(err));
      })
      .catch((err) => Promise.reject(err));
  }).then(function (result) {
    // Transaction has been committed
    res.sendStatus(204);
  }).catch(function (err) {
    Raven.captureException(err);
    response(res).error(err, 500);
  });
};

export default ({ config, db, validate, validation }) => resource({

  mergeParams: true,

  /** Property name to store preloaded entity on `request`. */
  id : 'model',

  load,

  /** GET / - List all entities */
  async index(req, res) {
    try {
      await Model.findAndCountAll({
        where: {
          caseId: req.params.caseId
        },
        order: [
          ['id', 'DESC']
        ],
        limit: req.query.limit,
        offset: req.skip
      }).then(results => {
        response(res).collectionPaginated(getPaginatorOptions(req, results));
      });
    } catch(err) {
      Raven.captureException(err);
      response(res).error(err, 500);
    }
  },

  /** POST / - Create a new entity */
  create: [
    validate(validation.services),
    async (req, res) => {
      let exists = false;
      let errorMessage = "";

      if(req.body.serviceType === 'eddLien') {
        exists = exists || await Model.findOne({where: {serviceType: "eddLien", caseId: req.params.caseId}});
        if(exists) {
          errorMessage = "Only one EDD Lien can be created.";
        }
      }

      if(req.body.serviceType === 'lienService') {
        exists = exists || await Model.findOne({where: {serviceType: "lienService", caseId: req.params.caseId}});
        if(exists) {
          errorMessage = "Only one Lien Service can be created.";
        }
      }

      if(exists) {
        response(res).error(errorMessage, 422);
      } else {
        try {
          await createService(db, req, res);
        } catch(err) {
          response(res).error(err, 422);
        }
      }
    }
  ],

  /** GET /:id - Return a given entity */
  read({ model }, res) {
    response(res).item(model);
  },

  /** PUT /:id - Update a given entity */
  update: [
    validate(validation.services),
    async (req, res) => {
      try {
        await updateServices(db, req, res);
      } catch(err) {
        response(res).error(err, 422);
      }
    }
  ]
});
